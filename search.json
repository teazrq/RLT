[{"path":"https://teazrq.github.io/RLT/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ruoqing Zhu. Author, maintainer, copyright holder. Sarah Formentini. Author. Haowen Zhou. Contributor. Tianning Xu. Contributor. Zhechao Huang. Contributor.","code":""},{"path":"https://teazrq.github.io/RLT/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Zhu R. (). Reinforcement Learning Trees, R package version 4.1.5. Zhu, R., Zeng, D., & Kosorok, M. R. (2015). Reinforcement learning trees. Journal American Statistical Association, 110(512), 1770-1784. Zhu, R. & Kosorok, M. R. (2012). Recursively imputed survival trees. Journal American Statistical Association, 107(497), 331-340.","code":"@Manual{,   title = {RLT: Reinforcement Learning Trees},   author = {R. Zhu},   publisher = {manual},   note = {R package version 4.1.5},   url = {https://cran.r-project.org/package=RLT},   pdf = {https://cran.r-project.org/web/packages/RLT/RLT.pdf}, } @Article{,   title = {Reinforcement Learning Trees},   author = {Ruoqing Zhu and Donglin Zeng and Michael R. Kosorok},   journal = {Journal of the American Statistical Association},   year = {2015},   volume = {110},   number = {512},   pages = {1770-1784},   doi = {10.1080/01621459.2015.1036994},   url = {http://dx.doi.org/10.1080/01621459.2015.1036994}, } @Article{,   title = {Recursively imputed survival trees},   author = {Ruoqing Zhu and Michael R. Kosorok},   journal = {Journal of the American Statistical Association},   year = {2012},   volume = {107},   number = {497},   pages = {331-340},   doi = {10.1080/01621459.2011.637468},   url = {http://dx.doi.org/10.1080/01621459.2011.637468}, }"},{"path":"https://teazrq.github.io/RLT/index.html","id":"rlt","dir":"","previous_headings":"","what":"Reinforcement Learning Trees","title":"Reinforcement Learning Trees","text":"new version (>= 4.0.0) RLT package. Versions prior 4.0.0 written C (available RLT-Archive), newer versions based C++. new version replace original CRAN package finished. goal RLT provide new functionalities random forest models. includes embedded model fit learning better splitting rule; linear combination splits, confidence intervals, several new approaches currently developed.","code":""},{"path":"https://teazrq.github.io/RLT/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Reinforcement Learning Trees","text":"can install version using want use embedded model feature, need install released version (currently ver. 3.2.5) RLT CRAN :","code":"# install.packages(\"devtools\")     devtools::install_github(\"teazrq/RLT\") install.packages(\"RLT\")"},{"path":"https://teazrq.github.io/RLT/index.html","id":"new-features-highlight","dir":"","previous_headings":"","what":"New features highlight","title":"Reinforcement Learning Trees","text":"Unbiased variance estimation (regression forest) based Xu, Zhu Shao (2022+) Unbiased survival function confidence band estimation based Formentini, Liang Zhu (2022+) Reproducibility parallel tree version xoshiro256plus random number generator Speed space improvement earlier c version [implemented] Graph random forests [implemented] Python API","code":""},{"path":"https://teazrq.github.io/RLT/reference/QuanForest.html","id":null,"dir":"Reference","previous_headings":"","what":"QuanForest — QuanForest","title":"QuanForest — QuanForest","text":"Internal function fitting quantile forest","code":""},{"path":"https://teazrq.github.io/RLT/reference/QuanForest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"QuanForest — QuanForest","text":"","code":"QuanForest(x, y, ncat, obs.w, var.w, resample.preset, param, ...)"},{"path":"https://teazrq.github.io/RLT/reference/RLT.html","id":null,"dir":"Reference","previous_headings":"","what":"            Reinforcement Learning Trees\n — RLT","title":"            Reinforcement Learning Trees\n — RLT","text":"activate embedded model splitting variable selection, use reinforcement = TRUE. specify parameters embedded models, see definition param.control.","code":"Fit models for regression, classification and                     survival analysis using reinforced splitting rules.                    The model reduces to regular random forests if                     reinforcement is turned off."},{"path":"https://teazrq.github.io/RLT/reference/RLT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"            Reinforcement Learning Trees\n — RLT","text":"","code":"RLT(   x,   y,   censor = NULL,   model = NULL,   ntrees = if (reinforcement) 100 else 500,   mtry = max(1, as.integer(ncol(x)/3)),   nmin = max(1, as.integer(log(nrow(x)))),   split.gen = \"random\",   nsplit = 1,   resample.replace = TRUE,   resample.prob = if (resample.replace) 1 else 0.8,   resample.preset = NULL,   obs.w = NULL,   var.w = NULL,   importance = FALSE,   reinforcement = FALSE,   param.control = list(),   ncores = 0,   verbose = 0,   seed = NULL,   ... )"},{"path":"https://teazrq.github.io/RLT/reference/RLT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"            Reinforcement Learning Trees\n — RLT","text":"x matrix data.frame features. x data.frame, factors treated categorical variables. y Response variable. numeric/factor vector. censor Censoring indicator survival model used. model model type: \"regression\", \"classification\", \"quantile\", \"survival\" \"graph\". ntrees Number trees, ntrees = 100 reinforcement used ntrees = 1000 otherwise. mtry Number randomly selected variables used internal node. nmin Terminal node size. Splitting stop internal node size less equal nmin. split.gen cutting points generated: \"random\", \"rank\" \"best\". minimum child node size enforced (alpha $> 0$), \"rank\" \"best\" used. nsplit Number random cutting points compare variable internal node. resample.replace Whether -bag samples obtained replacement. resample.prob Proportion -bag samples. resample.preset pre-specified matrix -bag data indicator/count matrix. must \\(n \\times\\) ntrees matrix integer entries. Positive number indicates number copies observation (row) corresponding tree (column); zero indicates --bag; negative values indicates used either. Extremely large counts recommended. sum column exceed \\(n\\). obs.w Observation weights. weights used calculating splitting scores, sampling observations. experimental feature currently implemented regression. var.w Variable weights. supplied, default perform weighted sampling mtry variables. usage, see details split.rule param.control. importance Whether calculate variable importance measures. calculation follows Breiman's original permutation strategy. reinforcement reinforcement splitting rule used. Default \"FALSE\", .e., regular random forests marginal search splitting variable. activated, embedded model fitted find best splitting variable linear combination , linear.comb $> 1$. can also specified param.control. param.control list additional parameters. can used specify features random forest set embedded model parameters reinforcement splitting rules. Using reinforcement = TRUE automatically generate default tuning. necessarily optimized. embed.ntrees: number trees embedded model embed.resample.prob: proportion samples (internal node) embedded model embed.mtry: number proportion variables embed.split.gen random cutting point search method (\"random\", \"rank\" \"best\") embed.nsplit number random cutting points.   ncores Number cores. Default 0 (using available cores). verbose Whether info printed. seed Random seed number replicate previously fitted forest. Internally, xoshiro256++ generator used. specified, seed generated automatically. ... Additional arguments.","code":"\\code{linear.comb} is a separate feature that can be activated                     with or without using reinforcement. It creates linear combination of                     features as the splitting rule. Currently only available for regression and classification.                     \\itemize{                    \\item In reinforcement mode, a linear combination is created using the top continuous                     variables from the embedded model. If a categorical variable is the best, then a regular                     split will be used. The splitting point will be searched based on \\code{split.rule} of the                    model.                     \\item In non-reinforcement mode, a marginal screening is performed and the top features                     are used to construct the linear combination. This is an experimental feature.                     }                                        \\code{split.rule} is used to specify the criteria used to compare different splittings.                    Here are the available choices. The first one is the default:                    \\itemize{                    \\item Regression: `\"var\"` (variance reduction); `\"pca\"` and `\"sir\"` can be used for linear combination splits                    \\item Classification: `\"gini\"`                    \\item Survival: `\"logrank\"`, `\"suplogrank\"`, `\"coxgrad\"`.                    \\item Quantile: `\"ks\"` (Kolmogorov-Smirnov test)                    \\item Graph: `\"spectral\"` (spectral embedding)                    }                                        \\code{resample.track} indicates whether to keep track of the observations used in each tree.                                        \\code{var.ready} this is a feature to calculate variance of the random forest prediction                    Currently only available for regression (Xu, Zhu & Shao, 2023) and survival models (Formentini, Liang & Zhu, 2023).                     Specifying \\code{var.ready = TRUE} has the following effect:                    \\itemize{                    \\item \\code{resample.preset} is constructed automatically                    \\item \\code{resample.replace} is set to `FALSE`                    \\item \\code{resample.prob} is set to \\eqn{n / 2}                    \\item \\code{resample.track} is set to `TRUE`                    }                                        It is recommended to use a very large \\code{ntrees}, e.g, 10000 or larger.                     For \\code{resample.prob} greater than \\eqn{n / 2}, one should consider the approach in Xu, Zhu & Shao (2023).                                        \\code{alpha} force a minimum proportion of samples in each child node.                                        \\code{failcount} specifies the unique number of failure time points used in survival model.                     By default, all failure time points will be used. A smaller number may speed up the computation.                     The time points will be chosen uniformly on the quantiles of failure times."},{"path":"https://teazrq.github.io/RLT/reference/RLT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"            Reinforcement Learning Trees\n — RLT","text":"RLT fitted object, constructed list consisting FittedForestFitted tree structures VarImpVariable importance measures, importance = TRUE PredictionIn-bag prediction values OOBPredictionOut--bag prediction values resample.presetAn n \\(\\times\\) ntrees matrix indicates observations used tree. Provided resample.preset supplied, resample.track = TRUE, var.ready = TRUE survival forests, items provided NFailThe number observed failure times VarImpCovif VI.var=TRUE, estimated covariance matrix variable importance cindex_treeOut--bag c-index tree cindexOut--bag c-index forest timepointsordered observed failure times y.pointorder \\(y\\) observed failure times","code":""},{"path":"https://teazrq.github.io/RLT/reference/RLT.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"            Reinforcement Learning Trees\n — RLT","text":"Zhu, R., Zeng, D., & Kosorok, M. R. (2015) \"Reinforcement Learning Trees.\" Journal American Statistical Association. 110(512), 1770-1784. Xu, T., Zhu, R., & Shao, X. (2023) \"Variance Estimation Random Forests Infinite-Order U-statistics.\" arXiv preprint arXiv:2202.09008. Formentini, S. E., Wei L., & Zhu, R. (2022) \"Confidence Band Estimation Survival Random Forests.\" arXiv preprint arXiv:2204.12038.","code":""},{"path":"https://teazrq.github.io/RLT/reference/RegForest.html","id":null,"dir":"Reference","previous_headings":"","what":"RegForest — RegForest","title":"RegForest — RegForest","text":"Internal function fitting regression forest","code":""},{"path":"https://teazrq.github.io/RLT/reference/RegForest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RegForest — RegForest","text":"","code":"RegForest(x, y, ncat, obs.w, var.w, resample.preset, param, ...)"},{"path":"https://teazrq.github.io/RLT/reference/SurvForest.html","id":null,"dir":"Reference","previous_headings":"","what":"SurvForest — SurvForest","title":"SurvForest — SurvForest","text":"Internal function fitting survival forest","code":""},{"path":"https://teazrq.github.io/RLT/reference/SurvForest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SurvForest — SurvForest","text":"","code":"SurvForest(x, y, censor, ncat, obs.w, var.w, resample.preset, param, ...)"},{"path":"https://teazrq.github.io/RLT/reference/Surv_Cov_Forest.html","id":null,"dir":"Reference","previous_headings":"","what":"            Survival random forest with covariance estimation\n — Surv_Cov_Forest","title":"            Survival random forest with covariance estimation\n — Surv_Cov_Forest","text":"","code":"These trees will always be sampled without replacement.                    The choices of tuning parameters will be limited.                    Use at your own risk."},{"path":"https://teazrq.github.io/RLT/reference/Surv_Cov_Forest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"            Survival random forest with covariance estimation\n — Surv_Cov_Forest","text":"","code":"Surv_Cov_Forest(   x,   y,   censor,   testx,   ntrees = 10000,   mtry = max(1, as.integer(ncol(x)/3)),   nmin = max(1, as.integer(log(nrow(x)))),   split.gen = \"best\",   nsplit = 0,   resample.prob = 0.5,   param.control = list(),   ncores = 1,   verbose = 0,   seed = NULL,   ... )"},{"path":"https://teazrq.github.io/RLT/reference/Surv_Cov_Forest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"            Survival random forest with covariance estimation\n — Surv_Cov_Forest","text":"x matrix data.frame features y Response variable. numeric/factor vector. censor censoring indicator survival model used. testx matrix data.frame testing data ntrees Number trees. obtain stable accurate estimation, default ntrees = 10000. mtry Number randomly selected variables used internal node. nmin Terminal node size. used RLT. split.gen \"random\", \"rank\" \"best\". nsplit Number random cutting points compare variable internal node. resample.prob Proportion -bag samples. param.control list additional parameters. However, choices limited. example, reinforcement splitting rules implemented. ncores Number cores. Default 0 (using available cores). verbose Whether fitting info printed. seed Random seed number replicate previously fitted forest. Internally, xoshiro256++ generator used. specified, seed generated automatically. ... Additional arguments.","code":""},{"path":"https://teazrq.github.io/RLT/reference/Surv_Cov_Forest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"            Survival random forest with covariance estimation\n — Surv_Cov_Forest","text":"","code":"Prediction and covariance estimation of the testing data"},{"path":"https://teazrq.github.io/RLT/reference/check_control.html","id":null,"dir":"Reference","previous_headings":"","what":"check_control — check_control","title":"check_control — check_control","text":"check_control","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_control — check_control","text":"","code":"check_control(control, param)"},{"path":"https://teazrq.github.io/RLT/reference/check_importance.html","id":null,"dir":"Reference","previous_headings":"","what":"check_importance — check_importance","title":"check_importance — check_importance","text":"check_importance","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_importance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_importance — check_importance","text":"","code":"check_importance(importance)"},{"path":"https://teazrq.github.io/RLT/reference/check_mtry.html","id":null,"dir":"Reference","previous_headings":"","what":"check_mtry — check_mtry","title":"check_mtry — check_mtry","text":"check_mtry","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_mtry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_mtry — check_mtry","text":"","code":"check_mtry(mtry, p)"},{"path":"https://teazrq.github.io/RLT/reference/check_ncores.html","id":null,"dir":"Reference","previous_headings":"","what":"check_ncores — check_ncores","title":"check_ncores — check_ncores","text":"check_ncores","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_ncores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_ncores — check_ncores","text":"","code":"check_ncores(ncores)"},{"path":"https://teazrq.github.io/RLT/reference/check_nmin.html","id":null,"dir":"Reference","previous_headings":"","what":"check_nmin — check_nmin","title":"check_nmin — check_nmin","text":"check_nmin","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_nmin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_nmin — check_nmin","text":"","code":"check_nmin(nmin)"},{"path":"https://teazrq.github.io/RLT/reference/check_nsplit.html","id":null,"dir":"Reference","previous_headings":"","what":"check_nsplit — check_nsplit","title":"check_nsplit — check_nsplit","text":"check_nsplit","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_nsplit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_nsplit — check_nsplit","text":"","code":"check_nsplit(nsplit)"},{"path":"https://teazrq.github.io/RLT/reference/check_ntrees.html","id":null,"dir":"Reference","previous_headings":"","what":"check_ntrees — check_ntrees","title":"check_ntrees — check_ntrees","text":"check_ntrees","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_ntrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_ntrees — check_ntrees","text":"","code":"check_ntrees(ntrees)"},{"path":"https://teazrq.github.io/RLT/reference/check_obsw.html","id":null,"dir":"Reference","previous_headings":"","what":"check_obsw — check_obsw","title":"check_obsw — check_obsw","text":"check_obsw","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_obsw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_obsw — check_obsw","text":"","code":"check_obsw(obs.w, n)"},{"path":"https://teazrq.github.io/RLT/reference/check_reinforcement.html","id":null,"dir":"Reference","previous_headings":"","what":"check_reinforcement — check_reinforcement","title":"check_reinforcement — check_reinforcement","text":"check_reinforcement","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_reinforcement.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_reinforcement — check_reinforcement","text":"","code":"check_reinforcement(reinforcement)"},{"path":"https://teazrq.github.io/RLT/reference/check_resamplepreset.html","id":null,"dir":"Reference","previous_headings":"","what":"check_resamplepreset — check_resamplepreset","title":"check_resamplepreset — check_resamplepreset","text":"check_resamplepreset","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_resamplepreset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_resamplepreset — check_resamplepreset","text":"","code":"check_resamplepreset(resample.preset, param, param.control)"},{"path":"https://teazrq.github.io/RLT/reference/check_resampleprob.html","id":null,"dir":"Reference","previous_headings":"","what":"check_resampleprob — check_resampleprob","title":"check_resampleprob — check_resampleprob","text":"check_resampleprob","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_resampleprob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_resampleprob — check_resampleprob","text":"","code":"check_resampleprob(resample.prob)"},{"path":"https://teazrq.github.io/RLT/reference/check_resamplereplace.html","id":null,"dir":"Reference","previous_headings":"","what":"check_resamplereplace — check_resamplereplace","title":"check_resamplereplace — check_resamplereplace","text":"check_resamplereplace","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_resamplereplace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_resamplereplace — check_resamplereplace","text":"","code":"check_resamplereplace(resample.replace)"},{"path":"https://teazrq.github.io/RLT/reference/check_seed.html","id":null,"dir":"Reference","previous_headings":"","what":"check_seed — check_seed","title":"check_seed — check_seed","text":"check_seed","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_seed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_seed — check_seed","text":"","code":"check_seed(seed)"},{"path":"https://teazrq.github.io/RLT/reference/check_splitgen.html","id":null,"dir":"Reference","previous_headings":"","what":"check_splitgen — check_splitgen","title":"check_splitgen — check_splitgen","text":"check_splitgen","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_splitgen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_splitgen — check_splitgen","text":"","code":"check_splitgen(split.gen)"},{"path":"https://teazrq.github.io/RLT/reference/check_varw.html","id":null,"dir":"Reference","previous_headings":"","what":"check_varw — check_varw","title":"check_varw — check_varw","text":"check_varw","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_varw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_varw — check_varw","text":"","code":"check_varw(var.w, n)"},{"path":"https://teazrq.github.io/RLT/reference/check_verbose.html","id":null,"dir":"Reference","previous_headings":"","what":"check_verbose — check_verbose","title":"check_verbose — check_verbose","text":"check_verbose","code":""},{"path":"https://teazrq.github.io/RLT/reference/check_verbose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_verbose — check_verbose","text":"","code":"check_verbose(verbose)"},{"path":"https://teazrq.github.io/RLT/reference/cindex.html","id":null,"dir":"Reference","previous_headings":"","what":"C-index — cindex","title":"C-index — cindex","text":"Calculate c-index survival data","code":""},{"path":"https://teazrq.github.io/RLT/reference/cindex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"C-index — cindex","text":"","code":"cindex(y, censor, pred, ...)"},{"path":"https://teazrq.github.io/RLT/reference/cindex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"C-index — cindex","text":"y survival time censor censoring indicator survival model used pred predicted value subject","code":""},{"path":"https://teazrq.github.io/RLT/reference/cindex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"C-index — cindex","text":"c-index","code":""},{"path":"https://teazrq.github.io/RLT/reference/forest.kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"      random forest kernel\n — forest.kernel","title":"      random forest kernel\n — forest.kernel","text":"","code":"Get random forest induced kernel weight matrix of testing samples               or between any two sets of data. This is an experimental feature.              Use at your own risk."},{"path":"https://teazrq.github.io/RLT/reference/forest.kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"      random forest kernel\n — forest.kernel","text":"","code":"forest.kernel(   object,   X1 = NULL,   X2 = NULL,   vs.train = FALSE,   verbose = FALSE,   ... )"},{"path":"https://teazrq.github.io/RLT/reference/forest.kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"      random forest kernel\n — forest.kernel","text":"object fitted RLT object. X1 dataset prediction. calculates \\(n_1 \\times n_1\\) kernel matrix X1. X2 dataset reference/training. X2 supplied, calculate \\(n_1 \\times n_2\\) kernel matrix. vs.train used, must original training data. vs.train calculate kernel weights respect training data. slightly different supplying training data X2 due re-samplings training process. use feature, must specify resample.track = TRUE param.control fitting forst. verbose Whether fitting printed. ... ...   Additional arguments.","code":""},{"path":"https://teazrq.github.io/RLT/reference/forest.kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"      random forest kernel\n — forest.kernel","text":"kernel matrix contains kernel weights observation X1 respect X1","code":""},{"path":"https://teazrq.github.io/RLT/reference/get.one.tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a single tree — get.one.tree","title":"Print a single tree — get.one.tree","text":"Print single fitted tree forest object","code":""},{"path":"https://teazrq.github.io/RLT/reference/get.one.tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a single tree — get.one.tree","text":"","code":"get.one.tree(x, tree = 1, ...)"},{"path":"https://teazrq.github.io/RLT/reference/get.one.tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a single tree — get.one.tree","text":"x fitted RLT object tree tree number, starting 1 ntrees. ... ...","code":""},{"path":"https://teazrq.github.io/RLT/reference/my_sample.html","id":null,"dir":"Reference","previous_headings":"","what":"            samples\n — my_sample","title":"            samples\n — my_sample","text":"","code":"testing function"},{"path":"https://teazrq.github.io/RLT/reference/my_sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"            samples\n — my_sample","text":"","code":"my_sample(Num, min, max)"},{"path":"https://teazrq.github.io/RLT/reference/predict.RLT.html","id":null,"dir":"Reference","previous_headings":"","what":"prediction using RLT — predict.RLT","title":"prediction using RLT — predict.RLT","text":"Predict outcome (regression, classification survival) using fitted RLT object","code":""},{"path":"https://teazrq.github.io/RLT/reference/predict.RLT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prediction using RLT — predict.RLT","text":"","code":"# S3 method for RLT predict(   object,   testx = NULL,   var.est = FALSE,   keep.all = FALSE,   ncores = 1,   verbose = 0,   ... )"},{"path":"https://teazrq.github.io/RLT/reference/predict.RLT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prediction using RLT — predict.RLT","text":"object fitted RLT object testx testing samples, must structure training samples var.est Whether estimate variance testing data. original forest must fitted var.ready = TRUE. survival forests, calculates covariance matrix observed time points calculates critical value confidence band. keep.whether keep prediction trees ncores number cores ... ...","code":""},{"path":"https://teazrq.github.io/RLT/reference/predict.RLT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"prediction using RLT — predict.RLT","text":"RLT prediction object, constructed list consisting Prediction Prediction Variance var.est = TRUE fitted object var.ready = TRUE Survival Forests hazard predicted hazard functions CumHazard predicted cumulative hazard function Survival predicted survival function Allhazard keep.= TRUE, predicted hazard function observation tree AllCHF keep.= TRUE, predicted cumulative hazard function observation tree Cov var.est = TRUE fitted object var.ready = TRUE. test subject, matrix size NFail\\(\\times\\)NFail NFail number observed failure times training data Var var.est = TRUE fitted object var.ready = TRUE. Marginal variance subject timepoints ordered observed failure times training data MarginalVar var.est = TRUE fitted object var.ready = TRUE. Marginal variance subject Cov matrix projected nearest positive definite matrix MarginalVarSmooth var.est = TRUE fitted object var.ready = TRUE. Marginal variance subject Cov matrix projected nearest positive definite matrix smoothed using Gaussian kernel smoothing CVproj var.est = TRUE fitted object var.ready = TRUE. Critical values calculate confidence bands around cumulative hazard predictions several confidence levels. Calculated using MarginalVar CVprojSmooth var.est = TRUE fitted object var.ready = TRUE. Critical values calculate confidence bands around cumulative hazard predictions several confidence levels. Calculated using MarginalVarSmooth","code":""},{"path":"https://teazrq.github.io/RLT/reference/print.RLT.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a RLT object — print.RLT","title":"Print a RLT object — print.RLT","text":"Print RLT object","code":""},{"path":"https://teazrq.github.io/RLT/reference/print.RLT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a RLT object — print.RLT","text":"","code":"# S3 method for RLT print(x, ...)"},{"path":"https://teazrq.github.io/RLT/reference/print.RLT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a RLT object — print.RLT","text":"x fitted RLT object ... ...","code":""}]
